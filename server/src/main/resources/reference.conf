stasis {
  server {
    service {
      internal-query-timeout = 3 seconds
      internal-query-timeout = ${?SERVER_SERVICE_INTERNAL_QUERY_TIMEOUT}

      api {
        interface = "localhost"
        interface = ${?SERVER_SERVICE_API_INTERFACE}
        port = 9090
        port = ${?SERVER_SERVICE_API_PORT}

        context {
          type = "server"
          type = ${?SERVER_SERVICE_API_CONTEXT_TYPE}
          protocol = "TLS" # one of [TLS, TLSv1, TLSv1.1, TLSv1.2]
          protocol = ${?SERVER_SERVICE_API_CONTEXT_PROTOCOL}

          keystore {
            path = ""
            path = ${?SERVER_SERVICE_API_CONTEXT_KEYSTORE_PATH}
            type = "PKCS12" # one of [PKCS12, JKS]
            type = ${?SERVER_SERVICE_API_CONTEXT_KEYSTORE_TYPE}
            password = ""
            password = ${?SERVER_SERVICE_API_CONTEXT_KEYSTORE_PASSWORD}
          }
        }
      }

      core {
        interface = "localhost"
        interface = ${?SERVER_SERVICE_CORE_INTERFACE}
        port = 9091
        port = ${?SERVER_SERVICE_CORE_PORT}

        context {
          type = "server"
          protocol = "TLS" # one of [TLS, TLSv1, TLSv1.1, TLSv1.2]
          protocol = ${?SERVER_SERVICE_CORE_CONTEXT_PROTOCOL}

          keystore {
            path = ""
            path = ${?SERVER_SERVICE_CORE_CONTEXT_KEYSTORE_PATH}
            type = "PKCS12" # one of [PKCS12, JKS]
            type = ${?SERVER_SERVICE_CORE_CONTEXT_KEYSTORE_TYPE}
            password = ""
            password = ${?SERVER_SERVICE_CORE_CONTEXT_KEYSTORE_PASSWORD}
          }
        }
      }
    }

    clients {
      core {
        context {
          enabled = false
          enabled = ${?SERVER_CLIENTS_CORE_CONTEXT_ENABLED}
          type = "client"
          protocol = "TLS" # one of [TLS, TLSv1, TLSv1.1, TLSv1.2]
          protocol = ${?SERVER_CLIENTS_CORE_CONTEXT_PROTOCOL}

          truststore {
            path = ""
            path = ${?SERVER_CLIENTS_CORE_CONTEXT_TRUSTSTORE_PATH}
            type = "PKCS12" # one of [PKCS12, JKS]
            type = ${?SERVER_CLIENTS_CORE_CONTEXT_TRUSTSTORE_TYPE}
            password = ""
            password = ${?SERVER_CLIENTS_CORE_CONTEXT_TRUSTSTORE_PASSWORD}
          }
        }
      }

      authentication {
        context {
          enabled = false
          enabled = ${?SERVER_CLIENTS_AUTHENTICATION_CONTEXT_ENABLED}
          type = "client"
          protocol = "TLS" # one of [TLS, TLSv1, TLSv1.1, TLSv1.2]
          protocol = ${?SERVER_CLIENTS_AUTHENTICATION_CONTEXT_PROTOCOL}

          truststore {
            path = ""
            path = ${?SERVER_CLIENTS_AUTHENTICATION_CONTEXT_TRUSTSTORE_PATH}
            type = "PKCS12" # one of [PKCS12, JKS]
            type = ${?SERVER_CLIENTS_AUTHENTICATION_CONTEXT_TRUSTSTORE_TYPE}
            password = ""
            password = ${?SERVER_CLIENTS_AUTHENTICATION_CONTEXT_TRUSTSTORE_PASSWORD}
          }
        }
      }
    }

    authenticators {
      users {
        issuer = "stasis-identity" # identity provider / service issuing JWTs
        issuer = ${?SERVER_AUTHENTICATORS_USERS_ISSUER}
        audience = "stasis-server" # server (this service)
        audience = ${?SERVER_AUTHENTICATORS_USERS_AUDIENCE}
        identity-claim = "sub"
        identity-claim = ${?SERVER_AUTHENTICATORS_USERS_IDENTITY_CLAIM}
        jwks-endpoint = "http://localhost:9090/jwks/jwks.json"
        jwks-endpoint = ${?SERVER_AUTHENTICATORS_USERS_JWKS_ENDPOINT}
        refresh-interval = 90 minutes
        refresh-interval = ${?SERVER_AUTHENTICATORS_USERS_REFRESH_INTERVAL}
        expiration-tolerance = 30 seconds
        expiration-tolerance = ${?SERVER_AUTHENTICATORS_USERS_TOLERANCE}
      }

      nodes {
        issuer = "stasis-identity" # identity provider / service issuing JWTs
        issuer = ${?SERVER_AUTHENTICATORS_NODES_ISSUER}
        audience = "stasis-server" # server (this service)
        audience = ${?SERVER_AUTHENTICATORS_NODES_AUDIENCE}
        identity-claim = "sub"
        identity-claim = ${?SERVER_AUTHENTICATORS_NODES_IDENTITY_CLAIM}
        jwks-endpoint = "http://localhost:9090/jwks/jwks.json"
        jwks-endpoint = ${?SERVER_AUTHENTICATORS_NODES_JWKS_ENDPOINT}
        refresh-interval = 90 minutes
        refresh-interval = ${?SERVER_AUTHENTICATORS_NODES_REFRESH_INTERVAL}
        expiration-tolerance = 30 seconds
        expiration-tolerance = ${?SERVER_AUTHENTICATORS_NODES_TOLERANCE}
      }

      instance {
        token-endpoint = "http://localhost:9090/oauth/token"
        token-endpoint = ${?SERVER_AUTHENTICATORS_INSTANCE_TOKEN_ENDPOINT}
        client-id = "" # server's client ID, as registered in identity provider
        client-id = ${?SERVER_AUTHENTICATORS_INSTANCE_CLIENT_ID}
        client-secret = "" # server's client secret, as registered in identity provider
        client-secret = ${?SERVER_AUTHENTICATORS_INSTANCE_CLIENT_SECRET}
        expiration-tolerance = 30 seconds
        expiration-tolerance = ${?SERVER_AUTHENTICATORS_INSTANCE_TOLERANCE}
        use-query-string = false
        use-query-string = ${?SERVER_AUTHENTICATORS_INSTANCE_USE_QUERY_STRING}
      }
    }

    persistence {
      database {
        url = "jdbc:h2:mem:server"
        url = ${?SERVER_PERSISTENCE_DATABASE_URL}
        driver = "org.h2.Driver"
        driver = ${?SERVER_PERSISTENCE_DATABASE_DRIVER}
        user = ""
        user = ${?SERVER_PERSISTENCE_DATABASE_USER}
        password = ""
        password = ${?SERVER_PERSISTENCE_DATABASE_PASSWORD}
        keep-alive-connection = true
        keep-alive-connection = ${?SERVER_PERSISTENCE_KEEP_ALIVE_CONNECTION}
      }

      users {
        salt-size = 16
        salt-size = ${?SERVER_PERSISTENCE_USERS_SALT_SIZE}
      }

      reservations {
        expiration = 1 minute
        expiration = ${?SERVER_PERSISTENCE_RESERVATIONS_EXPIRATION}
      }

      nodes {
        caching-enabled = true
        caching-enabled = ${?SERVER_PERSISTENCE_NODES_CACHING_ENABLED}
      }

      staging {
        enabled = false
        enabled = ${?SERVER_PERSISTENCE_STAGING_ENABLED}
        destaging-delay = 1 minute
        destaging-delay = ${?SERVER_PERSISTENCE_STAGING_DESTAGING_DELAY}
        store {
          type = "" # one of [memory, container, file]
          type = ${?SERVER_PERSISTENCE_STAGING_STORE_TYPE}
          memory {
            # Note: The JVM's memory settings (-Xms, -Xmx) must be adjusted
            #       to accommodate for this extra heap space usage.
            max-size = 4G
            max-size = ${?SERVER_PERSISTENCE_STAGING_STORE_MEMORY_MAX_SIZE}
            name = "memory-staging-store"
            name = ${?SERVER_PERSISTENCE_STAGING_STORE_MEMORY_NAME}
          }
          container {
            # Note: See `stasis.core.persistence.backends.file.container/README.md`
            #       for more information about these parameters and their usage.
            # Note: This default config (1M chunks @ 4KB each) will allow storage
            #       up to ~4GB (depending on number and size of crates).
            path = ""
            path = ${?SERVER_PERSISTENCE_STAGING_STORE_CONTAINER_PATH}
            max-chunk-size = 4K
            max-chunk-size = ${?SERVER_PERSISTENCE_STAGING_STORE_CONTAINER_MAX_CHUNK_SIZE}
            max-chunks = 1000000
            max-chunks = ${?SERVER_PERSISTENCE_STAGING_STORE_CONTAINER_MAX_CHUNKS}
          }
          file {
            # Note: No limit is enforced on how much data can be stored and it depends
            #       on the availablity of the underlying file-system volume.
            parent-directory = "" # path to directory for storing files
            parent-directory = ${?SERVER_PERSISTENCE_STAGING_STORE_FILE_PARENT_DIRECTORY}
          }
        }
      }
    }

    bootstrap {
      enabled = false
      enabled = ${?SERVER_BOOTSTRAP_ENABLED}
      config = "" # bootstrap config file
      config = ${?SERVER_BOOTSTRAP_CONFIG}
    }
  }
}

akka {
  loglevel = "INFO"
  loglevel = ${?SERVER_LOGLEVEL}

  http.server.server-header = ""
}
